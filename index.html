<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>DC Capital Bikeshare</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">
  <script src='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css' rel='stylesheet' />
  <style>
    #morning_commute_map,
    #evening_commute_map,
    #after_work_commute_map,
    #weekend_commute_map {
      height: 500px;
    }

    /*
 * The path-start class is added to each line
 * to manage its animation - this interpolates
 * between the starting and ending values for the
 * stroke-dashoffset css property
 */
    .path-start {
      -webkit-transition: stroke-dashoffset 5s ease-in;
      -moz-transition: stroke-dashoffset 5s ease-in;
      -o-transition: stroke-dashoffset 5s ease-in;
      transition: stroke-dashoffset 5s ease-in;
    }

    /*****D3 Barplot CSS modifications ******/
    .myaxis path {
      stroke: #FFFFFF;
    }

    .tick line {
      stroke: #FFFFFF
    }

    .tick text {
      fill: #FFFFFF
    }

    /*****End D3 Barplot CSS modifications *****/
    body {
      background-color: #121212;
    }

    h2 {
      color: #FFFFFF;
    }

    h3 {
      color: #ffffff;
    }

    h4 {
      color: #FFFFFF;
    }

    h5 {
      color: #FFFFFF;
    }

    p {
      color: #FFFFFF;
    }

    b {
      color: #FFFFFF;
    }

    A:link {
      COLOR: white;
      TEXT-DECORATION: none;
      font-weight: normal
    }

    A:visited {
      COLOR: purple;
      TEXT-DECORATION: none;
      font-weight: normal
    }

    A:active {
      COLOR: white;
      TEXT-DECORATION: none
    }

    A:hover {
      COLOR: blue;
      TEXT-DECORATION: none;
      font-weight: none
    }

    ol {
      color: #FFFFFF;
    }
  </style>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v4.min.js"></script>

  <!-- Leaflet HeatMap -->
  <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-heat/v0.1.3/leaflet-heat.js'></script>

  <!-- arc.js to make paths curved -->
  <script src='https://api.mapbox.com/mapbox.js/plugins/arc.js/v0.1.0/arc.js'></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>

<body>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h2>Mobility on Demand Systems: Data-Driven Analysis, Simulation, Visualization</h2>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Dr. Dimitris Papanikolaou | dpapanik@uncc.edu | Urban Synergetics Lab | https://urbansynergeticslab.net
      </p>
    </div>
    <div class="two columns">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid"
          src="img/img_1600/usl_logo_white_transparent.png" style="background-color:#121212"></a>
    </div>
    <div class="twelve columns">
      <h3>Introduction</h3>
      <p>

        The webpage presents the Visualized Data on the bike sharing system in Washington DC.
        Capital Bike share is the mainstay for the bike sharing service in the city with more than
        4500 bikes and 596 stations across the metro region of Washington,DC. The data was
        obtained from the website of Capitalbike share a href="https://www.capitalbikeshare.com">
        https://www.capitalbikeshare.com</a>. The
        Data incorporate several layers of information for instance : the bike IDs, time and locations
        Of the start and end of each trip. Duration of the trip, Users membership condition ( member
        or casual), and the bike type( electric, classic or docked).By analyzing and visualizing the
        data we are trying to answer the following questions : How the time impacts the length of
        the ride during the weekdays and the weekends in Washington DC,How do the time impact
        the start and end locations,and propose possible solutions to improve the efficiency of the
        Bike share system and elevate user experience.
      </p>
    </div>
  </div>

  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>How does time impact length of the ride?</h3>
      <!-- Create Barplot -->
      <div id="distance_plot"></div>
      <div id="time_plot"></div>
      <h4>
        Findings
      </h4>
      <p>
        The two peaks of total distance of ride in the fist graph indicates that the high
        usage of sharing bikes occurs around 7- 8 am and 3-6 pm. Since the second peak is
        significantly higher than the morning peak. It suggests that people tend to use bikes
        for travelling in the afternoon. The second graph has a similar profile to the first one
        except for at 1 pm, which means that the bike travelling speed doesn’t change a lot
        for the most part of the day. Considering the oscillation of traffic volume, the drastic
        increase of the duration of rides at 1 pm maybe the result of heavy traffic condition
        during the rush hour.
      </p>
    </div>
  </div>


  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>How does time impact start/end locations?</h3>
      <p>We are visualizing the flow of bike travel in the city by classifying the trip endpoints into clusters and
        mapping the flow of bike traffic between the clusters.
        The clusters were used in order to reduce the dimensionality of the data visualizations and they were created
        using a k-means algorithm.
        We used k-means because it would group similar points together and form local clusters in different regions of
        Washington DC.
        We had k-means compute ten clusters and we used the latitude and longitude points of the trip start and end
        locations.
        Once the clusters were created, we mapped the start locations to the maps below and color coordinated the start
        point to their cluster.
        The accompanying chord graph shows the flow of traffic between the clusters.
        <br><br>
        <b>Legend: </b><br>
      </p>
      <table style="width:100%">
        <tr>
          <td><span style="background-color: rgb(255, 0, 0)">Cluster 0</span></td>
          <td><span style="background-color: rgb(26, 255, 255)">Cluster 1</span></td>
          <td><span style="background-color: rgb(0, 255, 0)">Cluster 2</span></td>
          <td><span style="background-color: rgb(255, 0, 255)">Cluster 3</span></td>
          <td><span style="background-color: rgb(0, 255, 153)">Cluster 4</span></td>
          <td><span style="background-color: rgb(26, 117, 255)">Cluster 5</span></td>
          <td><span style="background-color: rgb(242, 242, 242)">Cluster 6</span></td>
          <td><span style="background-color: rgb(255, 255, 0)">Cluster 7</span></td>
          <td><span style="background-color: rgb(255, 51, 153)">Cluster 8</span></td>
          <td><span style="background-color: rgb(255, 153, 0)">Cluster 9</span></td>
        </tr>
      </table>
      <h4>Morning Commute</h4>
      <p>Weekdays 6am-10am</p>
      <div class="row">
        <div id="morning_commute_map" class="six columns"></div>
        <div id="morning_chord" class="six columns"></div>
      </div>
      <br>
      <p>
        Most of the trips were made from the northwest Washington including Columbia
        Heights neighborhood. The trip destinations were mainly the northwest Washington, the downtown area, and the
        Capitol Hill area. There are also some riders (small proportion) that commute from the Capital Hill area
        to the Washington city center. And others that travel from the Capital Hill to the
        Georgetown neighborhood.
      </p>
      <br>
      <h4>Evening Commute</h4>
      <p>Weekdays 5pm-8pm</p>
      <div class="row">
        <div id="evening_commute_map" class="six columns"></div>
        <div id="evening_chord" class="six columns"></div>
      </div>
      <br>
      <p>
        In the evening most trips are either within the same clusters (neighborhoods) or from
        downtown, Georgetown, Capital Hill neighborhoods to Northwest Washington, D.C..
      </p>
      <br>
      <h4>After Work Hours</h4>
      <p>Weekdays 8pm-2am the following day</p>
      <div class="row">
        <div id="after_work_commute_map" class="six columns"></div>
        <div id="after_work_chord" class="six columns"></div>
      </div>
      <br>
      <p>
        The overall number of trips went down and most of the trips were on Friday night.
        Most riders commute within the same neighborhoods. Late riders are mostly in the Northwest Washington including
        Columbia Heights neighborhood.
        Some late riders travel from the Georgetown neighborhood to the Northwest Washington.
      </p>
      <br>
      <h4>Weekend</h4>
      <p>All hours on the weekend</p>
      <div class="row">
        <div id="weekend_commute_map" class="six columns"></div>
        <div id="weekend_chord" class="six columns"></div>
      </div>
      <br>
      <p>
        Most of the riders commute from the Northwest Washington with a considerable
        proportion of trips within the neighborhood. Most of destinations are located in the city center and the Capital
        Hill neighborhood.
      </p>
    </div>
  </div>

  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>Conclusion</h3>
      <p>
        To conclude, the analysis explores the Bike sharing system visualized in Washington DC
        focusing on the two questions: how time impacts the length of ride and how time impacts
        the start/end locations analyzing using BarPlots, Maps and Chord Graphs. Our
        visualizations are helpful in presenting interesting insights from the data of capital Bikeshare
        such as specific time frames have higher usage of the sharing bikes during the day and the
        flow of the bike traffic between the clusters in particular time frames. Further, we hope to
        enrich our analysis with new findings and visualizations to bring out better solutions to
        increase the use of shared bikes in the Washington, DC.
      </p>
    </div>
  </div>

  <div class="container one-bottom">
    <h3>Team & Contributions</h3>
    <h4>Eric Helfrich</h4>
    <p>Edited the HTML/CSS/Javascript and wrote the python code to clean the data.
      for use JavaScript.</p>
    <h4>Ling Xu</h4>
    <p>Analyzed the barplot findings and made corrections to the plots.</p>
    <h4>Panick Kalambay Ilunga</h4>
    <p>Wrote the initial code for the D3 barplots and wrote the findings for the chord graphs</p>
    <h4>Khyati Patel</h4>
    <p>Helped with the chord graphs and wrote the introduction and conclusion</p>
  </div>





  <script>

    L.mapbox.accessToken = 'pk.eyJ1IjoiZWhlbGZyaWNoIiwiYSI6ImNra3Zhcmg5MDF1a3YycW55bmttcXA5NWEifQ.A1pr7k28x6Tf3--cUny6tA';

    /*
    * Distance Barplot
    */
    d3.csv("data/distance_matrix.csv", function (distance_data) {
      // set the dimensions and margins of the graph
      var margin = { top: 30, right: 10, bottom: 70, left: 50 },
        width = 860 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3.select("#distance_plot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

      // X axis
      var x = d3.scaleBand()
        .range([0, width])
        .domain(distance_data.map(function (d) { return d.group; }))
        .padding(0.3);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .attr("class", "myaxis")
        .call(d3.axisBottom(x));

      // Add X axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("x", width - 325)
        .attr("y", height + margin.top + 10)
        .style('fill', 'white')
        .text("Time of the day [h]");

      // Add Y axis
      var y = d3.scaleLinear()
        .domain([0, 6000])
        .range([height, 0]);
      svg.append("g")
        .attr("class", "myaxis")
        .call(d3.axisLeft(y));

      // Y axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", - margin.left + 11)
        .attr("x", - margin.top - 10)
        .style('fill', 'white')
        .text("Total distance of bike rides [km]");

      // A function that create / update the plot for a given variable:
      function update(data) {
        var u = svg.selectAll("rect")
          .data(data)

        u
          .enter()
          .append("rect")
          .merge(u)
          .transition()
          .duration(1000)
          .attr("x", function (d) { return x(d.group); })
          .attr("y", function (d) { return y(d.value); })
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", function (d) {
            // return "rgba(0.5, 1, " + (y(d.value) * .5) + ")";
            return "rgba(" + (y(d.value) * .7) + ", 1, 1)";
          });
      }

      // Initialize the plot with the first dataset
      update(distance_data)
    });

    /*
    * Time Barplot
    */
    d3.csv("data/time_matrix.csv", function (time_data) {
      console.log(time_data);
      // set the dimensions and margins of the graph
      var margin = { top: 30, right: 10, bottom: 70, left: 60 },
        width = 860 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3.select("#time_plot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

      // X axis
      var x = d3.scaleBand()
        .range([0, width])
        .domain(time_data.map(function (d) { return d.group; }))
        .padding(0.3);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .attr("class", "myaxis")
        .call(d3.axisBottom(x));

      // Add X axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("x", width - 325)
        .attr("y", height + margin.top + 10)
        .style('fill', 'white')
        .text("Time of the day [h]");

      // Add Y axis
      var y = d3.scaleLinear()
        .domain([0, 80000])
        .range([height, 0]);
      svg.append("g")
        .attr("class", "myaxis")
        .call(d3.axisLeft(y));

      // Y axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", - margin.left + 12)
        .attr("x", - margin.top - 10)
        .style('fill', 'white')
        .text("Total duration of the ride [min]")

      // A function that create / update the plot for a given variable:
      function update(data) {
        var u = svg.selectAll("rect")
          .data(data)

        u
          .enter()
          .append("rect")
          .merge(u)
          .transition()
          .duration(1000)
          .attr("x", function (d) { return x(d.group); })
          .attr("y", function (d) { return y(d.value); })
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", function (d) {
            return "rgba(0.5, 1, " + (y(d.value) * 1.2) + ")";
          });
      }

      // Initialize the plot with the first dataset
      update(time_data)
    });


    /*
    * Morning Commute Map
    */
    d3.csv("data/morning_commute.csv", function (data) {
      console.log(data)
      var morning_commute_map = L.mapbox.map('morning_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      morning_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
        }
      });
    });

    /*
    * Morning Chord Graph
    */
    d3.text("data/morning_commute_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#morning_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });

    /*
    * Evening Commute Map
    */
    d3.csv("data/evening_commute.csv", function (data) {
      var evening_commute_map = L.mapbox.map('evening_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      evening_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
        }
      });
    });

    /*
    * Evening Chord Graph
    */
    d3.text("data/evening_commute_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#evening_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });

    /*
    * After Work Commute Map
    */
    d3.csv("data/after_work.csv", function (data) {
      var after_work_commute_map = L.mapbox.map('after_work_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      after_work_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      function obj(ll) {
        return {
          x: ll[1],
          y: ll[0]
        };
      }
      i = 0;
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
        }
      });
    });

    /*
    * After Work Chord Graph
    */
    d3.text("data/after_work_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#after_work_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });

    /*
    * Weekend Commute Map
    */
    d3.csv("data/weekend.csv", function (data) {
      var weekend_commute_map = L.mapbox.map('weekend_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      weekend_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      function obj(ll) {
        return {
          x: ll[1],
          y: ll[0]
        };
      }
      i = 0;
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
        }
      });
    });

    /*
    * Weekend Chord Graph
    */
    d3.text("data/weekend_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#weekend_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });


  </script>


</body>

</html>