<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>DC Capital Bikeshare</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">
  <script src='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css' rel='stylesheet' />
  <style>
    #morning_commute_map,
    #evening_commute_map,
    #after_work_commute_map,
    #weekend_commute_map {
    height: 500px;
  }

    /*
 * The path-start class is added to each line
 * to manage its animation - this interpolates
 * between the starting and ending values for the
 * stroke-dashoffset css property
 */
    .path-start {
      -webkit-transition: stroke-dashoffset 5s ease-in;
      -moz-transition: stroke-dashoffset 5s ease-in;
      -o-transition: stroke-dashoffset 5s ease-in;
      transition: stroke-dashoffset 5s ease-in;
    }

    /*****D3 Barplot CSS modifications ******/
    .myaxis path {
      stroke: #FFFFFF;
    }

    .tick line {
      stroke: #FFFFFF
    }

    .tick text {
      fill: #FFFFFF
    }

    /*****End D3 Barplot CSS modifications *****/
    body {
      background-color: #121212;
    }

    h2 {
      color: #FFFFFF;
    }

    h3 {
      color: #ffffff;
    }

    h4 {
      color: #FFFFFF;
    }

    h5 {
      color: #FFFFFF;
    }

    p {
      color: #FFFFFF;
    }

    b {
      color: #FFFFFF;
    }

    A:link {
      COLOR: white;
      TEXT-DECORATION: none;
      font-weight: normal
    }

    A:visited {
      COLOR: purple;
      TEXT-DECORATION: none;
      font-weight: normal
    }

    A:active {
      COLOR: white;
      TEXT-DECORATION: none
    }

    A:hover {
      COLOR: blue;
      TEXT-DECORATION: none;
      font-weight: none
    }

    ol {
      color: #FFFFFF;
    }
  </style>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v4.min.js"></script>

  <!-- Leaflet HeatMap -->
  <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-heat/v0.1.3/leaflet-heat.js'></script>

  <!-- arc.js to make paths curved -->
  <script src='https://api.mapbox.com/mapbox.js/plugins/arc.js/v0.1.0/arc.js'></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>

<body>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h2>Mobility on Demand Systems: Data-Driven Analysis, Simulation, Visualization</h2>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Dr. Dimitris Papanikolaou | dpapanik@uncc.edu | Urban Synergetics Lab | https://urbansynergeticslab.net
      </p>
    </div>
    <div class="two columns">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/img_1600/usl_logo_white_transparent.png"
          style="background-color:#121212"></a>
    </div>
    <div class="twelve columns">
      <h3>Introduction</h3>
      <p>
        This webpage is providing visualized information about the bike sharing system in Washington
        DC. Capital Bikeshare is the provider of the bike-sharing service in the city. It currently owns
        4500+ bikes and 596 stations across 7 jurisdictions in the US. The data was captured from its
        website <a href="https://www.capitalbikeshare.com"> https://www.capitalbikeshare.com</a>.The data includes
        several layers of information such
        as: the bike ID, time and location of the start and the end of each ride, the user’s membership
        condition(member or casual), and the bike type(electric, classic, or docked).
        By analyzing and visualizing those data, we are trying to answer questions such as: How the
        demand for bikes in DC changes during a normal weekday on an hourly basis; From where
        most bike rides usually start; What destination the bike users are usually travelling to. The final
        goal of this analysis is to assess the overall performance of the sharing bike system in
        Washington DC, and propose possible solutions to improve the efficiency of the whole system
        so as to enhance users experience.
      </p>
    </div>
  </div>

  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>How does time impact length of the ride?</h3>
      <!-- Create Barplot -->
      <div id="distance_plot"></div>
      <div id="time_plot"></div>
      <p>
        ...
      </p>
      <h4>
        Findings
      </h4>
    </div>
  </div>


  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>How does time impact start/end locations?</h3>
      <p>Legend: ...</p>
      <h4>Morning Commute</h4>
      <p>Text about how data was found</p>
      <div class="row">
        <div id="morning_commute_map" class="six columns"></div>
        <div id="morning_chord" class="six columns"></div>
      </div>
      <br>
      <h4>Evening Commute</h4>
      <div class="row">
        <div id="evening_commute_map" class="six columns"></div>
        <div id="evening_chord" class="six columns"></div>
      </div>
      <br>
      <h4>After Work Hours</h4>
      <div class="row">
        <div id="after_work_commute_map" class="six columns"></div>
        <div id="after_work_chord" class="six columns"></div>
      </div>
      <br>
      <h4>Weekend</h4>
      <div class="row">
        <div id="weekend_commute_map" class="six columns"></div>
        <div id="weekend_chord" class="six columns"></div>
      </div>
    </div>
  </div>

  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>Conclusion</h3>
      <p>
        Add Conclusion!
      </p>
    </div>
  </div>

  <div class="container one-bottom">
    <h3>Team & Contributions</h3>
    <h4>Eric Helfrich</h4>
    <p>Edited the HTML/CSS/Javascript and developed the mapbox visualizations. Edited the descriptions and cleaned data
      for use JavaScript.</p>
    <h4>Ling Xu</h4>
    <p>Introduction and page layout ideas</p>
    <h4>Panick Kalambay Ilunga</h4>
    <p>clean and made the statistical computing & graphics (bar plots), edited the HTML JavaScript related to that
      section, and came up with some future questions we may address.</p>
    <h4>Khyati Patel</h4>
    <p>Description to maps, conclusion, and page layout ideas.</p>
  </div>





  <script>

    L.mapbox.accessToken = 'pk.eyJ1IjoiZWhlbGZyaWNoIiwiYSI6ImNra3Zhcmg5MDF1a3YycW55bmttcXA5NWEifQ.A1pr7k28x6Tf3--cUny6tA';

    /*
    * Distance Barplot
    */
    d3.csv("data/distance_matrix.csv", function (distance_data) {
      // set the dimensions and margins of the graph
      var margin = { top: 30, right: 10, bottom: 70, left: 50 },
        width = 860 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3.select("#distance_plot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

      // X axis
      var x = d3.scaleBand()
        .range([0, width])
        .domain(distance_data.map(function (d) { return d.group; }))
        .padding(0.3);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .attr("class", "myaxis")
        .call(d3.axisBottom(x));

      // Add X axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("x", width - 325)
        .attr("y", height + margin.top + 10)
        .style('fill', 'white')
        .text("Time of the day [h]");

      // Add Y axis
      var y = d3.scaleLinear()
        .domain([0, 6000])
        .range([height, 0]);
      svg.append("g")
        .attr("class", "myaxis")
        .call(d3.axisLeft(y));

      // Y axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", - margin.left + 11)
        .attr("x", - margin.top - 10)
        .style('fill', 'white')
        .text("Average distance of the Ride [km]");

      // A function that create / update the plot for a given variable:
      function update(data) {
        var u = svg.selectAll("rect")
          .data(data)

        u
          .enter()
          .append("rect")
          .merge(u)
          .transition()
          .duration(1000)
          .attr("x", function (d) { return x(d.group); })
          .attr("y", function (d) { return y(d.value); })
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", function (d) {
            return "rgba(0.5, 1, " + (y(d.value) * 1) + ")";
          });
      }

      // Initialize the plot with the first dataset
      update(distance_data)
    });

    /*
    * Time Barplot
    */
    d3.csv("data/time_matrix.csv", function (time_data) {
      console.log(time_data);
      // set the dimensions and margins of the graph
      var margin = { top: 30, right: 10, bottom: 70, left: 60 },
        width = 860 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3.select("#time_plot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

      // X axis
      var x = d3.scaleBand()
        .range([0, width])
        .domain(time_data.map(function (d) { return d.group; }))
        .padding(0.3);
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .attr("class", "myaxis")
        .call(d3.axisBottom(x));

      // Add X axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("x", width - 325)
        .attr("y", height + margin.top + 10)
        .style('fill', 'white')
        .text("Time of the day [h]");

      // Add Y axis
      var y = d3.scaleLinear()
        .domain([0, 80000])
        .range([height, 0]);
      svg.append("g")
        .attr("class", "myaxis")
        .call(d3.axisLeft(y));

      // Y axis label:
      svg.append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", - margin.left + 12)
        .attr("x", - margin.top - 10)
        .style('fill', 'white')
        .text("Average duration of the Ride [min]")

      // A function that create / update the plot for a given variable:
      function update(data) {
        var u = svg.selectAll("rect")
          .data(data)

        u
          .enter()
          .append("rect")
          .merge(u)
          .transition()
          .duration(1000)
          .attr("x", function (d) { return x(d.group); })
          .attr("y", function (d) { return y(d.value); })
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", function (d) {
            return "rgba(0.5, 1, " + (y(d.value) * 1) + ")";
          });
      }

      // Initialize the plot with the first dataset
      update(time_data)
    });


    /*
    * Morning Commute Map
    */
    d3.csv("data/morning_commute.csv", function (data) {
      console.log(data)
      var morning_commute_map = L.mapbox.map('morning_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      morning_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(morning_commute_map);
            break;
        }
      });
    });

    /*
    * Morning Chord Graph
    */
    d3.text("data/morning_commute_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#morning_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });

    /*
    * Evening Commute Map
    */
    d3.csv("data/evening_commute.csv", function (data) {
      var evening_commute_map = L.mapbox.map('evening_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      evening_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(evening_commute_map);
            break;
        }
      });
    });

    /*
    * Evening Chord Graph
    */
    d3.text("data/evening_commute_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#evening_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });

    /*
    * After Work Commute Map
    */
    d3.csv("data/after_work.csv", function (data) {
      var after_work_commute_map = L.mapbox.map('after_work_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      after_work_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      function obj(ll) {
        return {
          x: ll[1],
          y: ll[0]
        };
      }
      i = 0;
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(after_work_commute_map);
            break;
        }
      });
    });

    /*
    * After Work Chord Graph
    */
    d3.text("data/after_work_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#after_work_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });

    /*
    * Weekend Commute Map
    */
    d3.csv("data/weekend.csv", function (data) {
      var weekend_commute_map = L.mapbox.map('weekend_commute_map')
        .setView([38.896653139857385, -77.03485808499167], 12)
        .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/dark-v10'));
      weekend_commute_map
        .scrollWheelZoom.disable()

      var path_options = {};
      function obj(ll) {
        return {
          x: ll[1],
          y: ll[0]
        };
      }
      i = 0;
      data.forEach(function (row) {

        row.start_lat = +row.start_lat;
        row.start_lng = +row.start_lng;
        row.start_cluster = +row.start_cluster;

        switch (row.start_cluster) {
          case 0:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 1:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 255, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 2:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 3:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 0, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 4:
            path_options = {
              radius: 2,
              color: d3.rgb(0, 255, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 5:
            path_options = {
              radius: 2,
              color: d3.rgb(26, 117, 255),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 6:
            path_options = {
              radius: 2,
              color: d3.rgb(242, 242, 242),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 7:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 255, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 8:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 51, 153),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
          case 9:
            path_options = {
              radius: 2,
              color: d3.rgb(255, 153, 0),
              stroke: true,
              weight: 1,
            };
            L.circleMarker([row.start_lat, row.start_lng], path_options).addTo(weekend_commute_map);
            break;
        }
      });
    });

    /*
    * Weekend Chord Graph
    */
    d3.text("data/weekend_matrix.csv", function (data) {
      var matrix = d3.csvParseRows(data).map(function (row) {
        return row.map(function (value) {
          return +value;
        });
      });
      console.log(matrix[0][0])
      var svg = d3.select("#weekend_chord")
        .append("svg")
        .attr("width", 440)
        .attr("height", 440)
        .append("g")
        .attr("transform", "translate(220,220)")

      // create a matrix

      // 9 groups, so create a vector of 9 colors
      var colors = ["rgb(255, 0, 0)", "rgb(26, 255, 255)", "rgb(0, 255, 0)",
        "rgb(255, 0, 255)", "rgb(0, 255, 153)", "rgb(26, 117, 255)",
        "rgb(242, 242, 242)", "rgb(255, 255, 0)", "rgb(255, 51, 153)",
        "rgb(255, 153, 0)"]

      // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
      var res = d3.chord()
        .padAngle(0.05)
        .sortSubgroups(d3.descending)
        (matrix)

      // add the groups on the outer part of the circle
      svg
        .datum(res)
        .append("g")
        .selectAll("g")
        .data(function (d) { return d.groups; })
        .enter()
        .append("g")
        .append("path")
        .style("fill", function (d, i) { return colors[i] })
        .style("stroke", "black")
        .attr("d", d3.arc()
          .innerRadius(200)
          .outerRadius(210)
        )

      // Add the links between groups
      svg
        .datum(res)
        .append("g")
        .selectAll("path")
        .data(function (d) { return d; })
        .enter()
        .append("path")
        .attr("d", d3.ribbon()
          .radius(200)
        )
        .style("fill", function (d) { return (colors[d.source.index]) }) // colors depend on the source group. Change to target otherwise.
        .style("stroke", "#8c8c8c");
    });


  </script>


</body>

</html>